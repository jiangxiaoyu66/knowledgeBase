[前端性能优化 24 条建议（2020）](https://juejin.im/post/6892994632968306702#heading-16)

[系统认识JavaScript正则表达式](https://segmentfault.com/a/1190000014981826)

[ chainWebpack](https://umijs.org/config#chainwebpack)

[按需加载](https://umijs.org/zh-CN/docs/load-on-demand)





## 公司项目实践：

### 服务端渲染

客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。

服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。

- 优点：首屏渲染快，SEO 好。
- 缺点：配置麻烦，增加了服务器的计算压力。

> SSR 常用于以下两个场景：
>
> 1. 有 **SEO 诉求**，用在搜索引擎检索以及社交分享，用在前台类应用。
> 2. **首屏渲染**时长有要求，常用在移动端、弱网情况下。
>
> > 也就是说，如果你是中后台应用（如 antd pro、管理后台等），请谨慎考虑是否使用 SSR。
>
> 

>服务端渲染，首先得有后端服务器（一般是 Node.js）才可以使用，如果我没有后端服务器，也想用在上面提到的两个场景，那么推荐使用**预渲染**。
>
>预渲染与服务端渲染唯一的不同点在于**渲染时机**，服务端渲染的时机是在用户访问时执行渲染（即**实时渲染**，数据一般是最新的），预渲染的时机是在项目构建时，当用户访问时，数据不是一定是最新的（如果数据没有实时性，则可以直接考虑预渲染）。
>
>预渲染（Pre Render）在构建时执行渲染，将渲染后的 HTML 片段生成静态 HTML 文件。无需使用 web 服务器实时动态编译 HTML，适用于**静态站点生成**。



>
>
>### 如何判断当前页面是 SSR 还是 CSR？
>
>查看网页源代码，如果 `<div id="root">` DOM 里的元素不为空，则是 SSR，否则为 CSR。





# 前端图片加载优化

1. cdn，做图片的节点分发
2. http2，利用多路复用，投不压缩方式节省网络传输
3. webp，利用新型图片格式，可以无损压缩，文件体积更小
4. 小图片用svg,或者字体图标，或者base64
5. 小图片集合用雪碧图
6. 云端按需裁剪
7. image-webpack-loader，压缩项目中的图片





# link标签的优化

[通过rel="preload"进行内容预加载](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content)



# 简述前端性能优化

## 页面内容方面

1. 通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况；
2. 通过 DNS 缓存等机制来减少 DNS 的查询次数；
3. 通过设置缓存策略，对常用不变的资源进行缓存；
4. 通过延迟加载的方式，来减少页面首屏加载时需要请求的资源，延迟加载的资源当用户需要访问时，再去请求加载；
5. 通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度；
参考：[简述前端性能优化
](https://github.com/a1029563229/InterviewQuestions/tree/master/html/6)
## 服务器方面

1. 使用 CDN 服务，来提高用户对于资源请求时的响应速度；
2. 服务器端自用 Gzip、Deflate 等方式对于传输的资源进行压缩，减少传输文件的体积；
3. 尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie；



































配置cdn

[webpack](https://tower.im/teams/1f1b239be240415d8092cba39006cebe/search?tag=%23webpack) 字体icon压缩

http1.1升级为2.0

实现文件精确缓存

压缩文件

图片优化

按需加载