<img src="../../../../../AppData/Roaming/Typora/typora-user-images/image-20201028150024158.png" alt="image-20201028150024158"  />



# 攻击&防御

文章参考：

[[秃破前端面试] —— Web 安全相关](https://juejin.im/post/6844904029416357896)

[常见六大Web安全攻防解析](https://juejin.im/post/6844903772930441230#heading-5)

![image-20201028145245092](https://i.loli.net/2020/10/28/aKgCdkU23EIif8P.png)

## 前言

今年的面试难度据说涨了好几番，但是我想必考点应该还是那些。那web安全应该算是必考项了吧。当问及web攻击方式有哪些，如何预防的时候，各位小伙伴是不是一脸懵逼呢？今天，我们就来梳理一下，当涉及到网络安全的时候，我们应该如何回答？

## 问：说说网络安全有哪些攻击方式，攻击方式的特点是什么？如何预防？

答：

网络攻击方式有很多种，最常见的属于跨站脚本攻击和跨站请求伪造了。

跨站脚本攻击，缩写为xss。从攻击时限分分为两种：持续型和非持续性。

持续型是通过前端入口将攻击代码传递到数据库，导致使用该系统的人，一旦进入相关攻击页面，就会被攻击。除非数据库中的相关攻击代码被清除。

非持久型是通过前端入口将攻击代码提交给服务器，服务器执行相关而已代码，获取cookie，或者其他账户信息。如盗取qq号。

跨站请求伪造，缩写为crsf。csrf是通过用户登陆后服务端返回的cookie，进行伪造身份，从而发起的一种攻击，比如伪造你的身份去引号取钱。所以crsf的后果往往是不可逆的，但是他的执行条件比较多。需要用户在登录条件下访问了第三方的病毒网站，且需要攻击者了解被攻击网站的内部代码，从而摸清哪里有csrf漏洞。

除了这两种最常见的之外，还有一些，比如：点击劫持，url跳转漏洞

点击劫持，就是在一些敏感操作，比如登录的按钮上门，隐藏一个透明的iframe，诱导用户点击。

url跳转漏洞，就是在点击网站链接进行跳转的时候，没有对跳转的地址进行合法性验证，导致用户跳转到钓鱼页面。













# Http,Http2.0

![image-20201028150235262](https://i.loli.net/2020/10/28/HWiTV7nwz5kGgPC.png)



文章参考：

[HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)

[HTTP----HTTP2.0新特性](https://juejin.im/post/6844903545532071943#heading-1)

## Http协议

Http属于应用层，从1991年发展至今，迭代了几个版本，0.9，1.0，1.1，2.0.那我们就按照时间线依次说一说每个版本新增的特性吧

### 0.9

只能接受GET的请求方式，服务器返回的只能是html格式的字符串

### 1.0

新增了POST的请求方式，除了文字还可以传图像，视频，二进制文件。

请求和回应都新增了请求头和协议的版本。回应头信息的内部有Content-Type(数据格式),Content-Encoding（数据压缩方法）。

缺点是:每次TCP链接只能发送一个请求，下一个请求需要再一次进行TCP链接，因为有三次握手的缘故，TCP链接比较占用性能，随着网页加载的资源越来越多，问题也越来越暴露出来。虽然引入了connection:keep-alive的字段，但它属于非标准字段，可能会因为不同的实现方式出现不同的结果，所以不属于根本性的解决方案。



### 1.1

新增持久连接，即无需依赖connection字段指定，TCP链接默认是不关闭的，服务端可以一次接受多个请求。

管道机制，客户端可以一次发送多个请求。

有了持久链接，客户端就不需要等待tcp连接重开后再发下一次请求。有了管道连接，客户端也就不需要再同一个TCP链接中，等待上由此请求发送成功，服务端做出回应后再发下一次请求，可以直接发。只不过再服务端那边还是按照请求发送的顺序依次做出回应。

分块传输：

配合content-length字段，每一块都有自己的数据长度，如果数据长度达到了Content-Length，则进行下一块的传输，知道content-length为0为止。

还新增了更多请求方法：

DELETE,PUT,

HEAD（和GET一样，用于单纯的请求资源，但是HEAD的请求方式指只会返回响应头，一般用于读取服务器的性能）,

OPTIONS（和HEAD类似，用来获取服务器支持的所有请求方式，也可以判断是否对指定资源有访问权限）,

PATCH（PATCH和PUT的区别是PUT用于资源的整体更新，而PATCH用于资源的部分更新）

缺点：

虽然1.1版本允许TCP复用连接，但是服务器只会按照请求顺序对请求做出回应，容易造成队头阻塞，即第一个数据包受阻而导致的整个数据包受阻。

如何避免？减少请求数或者多开持久连接。

09年，为了解决HTTP1.0效率不高的问题，谷歌公开了自主研发的SPDY协议。

### 2.0

多工：为了解决1.1中队头阻塞的风险，2.0新推出多工的概念。什么叫作多工呢，就是在同一个TCP连接中，如果两个A和B，A和B，如果A先请求，但是由于时间过长，就先把A请求中已经处理好的数据回应给A，然后处理B请求。等到B请求完成后再处理A请求。

但是伴随这个的还有一个问题，就是因为多工的原因，现在的数据流不再一定是按照顺序发送的。那么如何将数据包和数据流对应起来呢（数据包：由于1.1版本的分块传输，导致每个数据流会被分为多块进行传输，这里的每一块在2.0里被称为数据包，数据流就是每个请求返回的**完整**数据）。所有的数据包都会对应一个他的数据流ID，用来区分谁属于谁。且客户端数据流的ID是奇数，服务端数据流的ID为偶数）



另一方面，为了提高传输效率，对头信息做了两个处理：

1.把头信息从原来的文本格式改为二进制格式，提高解析速度。且将二进制的头信息和二进制的数据体统称为“帧”，包括“头信息帧”和“数据帧”

2.使用gzip或者compress压缩头信息

3.客户端和服务端维护同一张头信息表，头信息中的所有字段全部有一个对应的索引号。后面同样的字段就 不发字段了，直接发索引号。

服务器推送，即允许服务器无需客户端发请求，主动向客户端推送资源。一般用在服务端觉得客户端会继续请求大量静态资源的时候，他会主动把资源推给客户端。



# 互联网协议

文章参考：

[互联网协议入门（一）](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)

[互联网协议入门（二）](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)

# Https

![image-20201028150249027](https://i.loli.net/2020/10/28/mqkyhbM65UKsBwv.png)



[文章参考：[秃破前端面试] —— HTTP && HTTPS](https://juejin.im/post/6844904029416341512)



# HTTP和HTTPS

[如何简单的从宏观上理解HTTP/HTTPS的加密过程？](https://juejin.cn/post/6844904167023050765)



# 跨域

![image-20201028150430491](https://i.loli.net/2020/10/28/6LbWD32aYripkqZ.png)

文章参考：[[秃破前端面试] —— 跨域实践总结](https://juejin.im/post/6844904029420519437)





# CooKie











# 三次握手

tcp标志位有6种标志：

SYN(synchronous建立联机) 

ACK(acknowledgement 确认) 

PSH(push传送) 

FIN(finish结束)

RST(reset重置) 

URG(urgent紧急)



而对应SYN和ACK的分别是Sequence number(顺序号码) 和Acknowledge number(确认号码)

--------



第一次握手：客户端发送位码syn=1，随机产生seq number=1234567。服务端由syn=1知道，客户端要求建立连接。

第二次握手：服务端在收到syn=1后知道客户端请求连接，所以向客户端发送ack=1，syn=1，ack number=(1234567+1), 随机的seq number=(123456) 的包

第三次握手：客户端检查ack number是否正确（即第一次发送的seq number+1），ack是否为1。

若正确，客户端再次发送ack=1，ack number=（123456+1）。服务端收到后确认ack和ack number，正确则建立连接成功

参考文章：[TCP三次握手中SYN，ACK，Seq三者的关系](https://blog.csdn.net/u014507230/article/details/45310847)



**为什么是3次握手，不是2次握手？**

2次握手只能保证客户端对服务端的确认，确认服务端没有问题；但是不能保证客户端是否能够正常接收服务端信息。





