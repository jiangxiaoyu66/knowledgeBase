## 页面导入样式时，使用 link 和 @import有什么区别？

### link

**HTML外部资源链接元素** (**`<link>`**) 规定了当前文档与外部资源的关系。该元素最常用于链接[样式表](https://developer.mozilla.org/zh-CN/docs/Glossary/CSS)，此外也可以被用来创建站点图标(比如PC端的“favicon”图标和移动设备上用以显示在主屏幕的图标) 。

>**mdn:**
	`rel` 表示“关系 (relationship) ”
>
>```html
><link rel="icon" href="favicon.ico">
>```
>
>```html
><link href="main.css" rel="stylesheet">
>```

### @import

> **`@import `**[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS)[@规则](https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule)，用于从其他样式表导入样式规则。

### link和@import的区别

本质上，这两种方式都是为了加载CSS文件，但还是存在着细微的差别

总的来说，@import只能用来加载css，且速度慢，兼容差，不能通过dom控制样式

1 老祖宗的差别。link属于XHTML标签，而[@import](https://github.com/import)完全是CSS提供的一种方式。

link标签除了可以加载CSS外，还可以做很多其它的事情，比如显示icon等，[@import](https://github.com/import)就只能加载CSS了。

2 加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而[@import](https://github.com/import)引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览用[@import](https://github.com/import)加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显.

3 兼容性的差别。由于[@import](https://github.com/import)是CSS2.1提出的所以老的浏览器不支持，[@import](https://github.com/import)只有在IE5以上的才能识别，而link标签无此问题。

4 使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为[@import](https://github.com/import)不是dom可以控制的。



## typeof来判断类型准确么？为什么？

不准确。typeof只能判断除null以外的基本数据类型。对于引用数据类型，除了function，其他都会判定为Object。

instanceof也不准确，他的原理是查看原型是否在原型链上（如：A instanceof B是用来判断B的原型是否在A的原型链上）





## 分析比较 opacity: 0、visibility: hidden、 display: none 优劣和适用场景？

结构：
display:none: 会让元素完全从渲染树中消失，不占任何空间, 不能点击，
visibility: hidden:不会从渲染树消失，占据空间，不能点击
opacity: 0: 不会从渲染树消失，占据空间，可以点击

继承：
display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。	
visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。

性能：
displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大
visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少。
opacity: 0 ： 修改元素会造成重绘，性能消耗较少

参考文章：[第 57 题：分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100#)



## 介绍下重绘和回流(Repaint & Reflow)， 以及如何进行优化?

### 重绘

render tree中的元素更新属性，且属性不影响布局，只影响样式的。如改变颜色和大小

### 回流

render tree中的元素，他们的布局或者几何属性发送改变，会触发回流

### 如何优化？

#### JS

1.最小化重绘和重排

- **避免频繁操作样式**，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。

2.批量修改DOM

- **避免频繁操作`DOM`**，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。

避免触发同步布局事件

- **避免频繁读取会引发回流/重绘的属性**，如果确实需要多次使用，就用一个变量缓存起来。



#### css

**从回流重绘角度**

1.**CSS3 硬件加速（GPU加速）**

使用transform，opacity，filters，will-change，触发CSS3硬件加速，避免回流重绘

2.**对具有复杂动画的元素使用绝对定位**，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

**从综合性能角度**

1.**避免使用`table`布局**，可能很小的一个小改动会造成整个 `table` 的重新布局。

2.**尽可能在`DOM`树的最末端改变`class`**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

3.**避免设置多层内联样式**，CSS 选择符**从右往左**匹配查找，避免节点层级过多。

4.**避免使用`CSS`表达式**，可能会引发回流。

解释：CSS 表达式致命的一点是，它执行zhi的频率远远超出了你的想象。dao理zhuan想情况是，我们shu希望这个表达式在页面加载或刷新的时候执行。事与愿违，只要页面一滚动，它就会重复执行，甚至鼠标移动的时候，它也会执行。
　　要知道80% 的用户喜欢使用鼠标在页面上移动，来帮助他们阅读或者根本就是漫无目的的移动。那就可以想象当用户阅读文章的时候，鼠标的移动量会有多大。因为CSS 表达式在鼠标移动的时候就会执行，所以光看这一个页面，CSS 表达式就执行上千遍，甚至上万遍。这对于用户体验来说简直就是灾难。



参考文章：[**介绍下重绘和回流（Repaint & Reflow），以及如何进行优化**](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24)



## flex-shrink，flex-grow默认值，flex 1代表什么？flex: none代表什么？flex:auto代表什么？

flex-shrink:空间不足时，缩放比例。默认为1，即空间不足时，该子元素占总共空间的1/n

flex-grow:空间剩余时，放大比例。默认为0，即不放大。j

flex-basis:当有剩余空间时，元素占的长度/高度，非比例，而是px，%这种单位。auto基本是和width：fit-content一样

flex为1：flex-grow flex-shrink flex-basis,默认值为0 1 auto。

flex: none代表什么？flex:auto代表什么？:`auto` (`1 1 auto`) 和 none (`0 0 auto`)。

参考文章：[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)



## 浏览器的渲染原理？

- 浏览器渲染
  - HTML parser --> DOM Tree
    - 标记化算法，进行元素状态的标记
    - dom 树构建
  - CSS parser --> Style Tree
    - 解析 css 代码，生成样式树
  - attachment --> Render Tree
    - 结合 dom树 与 style树，生成渲染树
  - layout: 布局,计算各节点的精确位置
  - GPU painting: 像素绘制页面



## 如何实现浏览器内多个标签页之间的通信?

1.window.opener

```js
window.opener.postMessage('START', '*');
window.addEventListener('message', handleWindowMessage, false);
```

2.localstorage

```js
window.onstorage = (e) => {console.log(e)}
// 或者这样
window.addEventListener('storage', (e) => console.log(e))
```

3.webworker中的sharedWorker

SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)

1.在服务端注册一个onmessage监听信息，客户端(即使用sharedWorker的标签页)发送message时就会触发。

注意：出于浏览器本身的安全机制，webworker无法在本地使用。

```js
// sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可
let data = "";
onconnect = function (e) {
  let port = e.ports[0];
  port.onmessage = function (e) {
    if (e.data === "get") {
      port.postMessage(data);
    } else {
      data = e.data;
    }
  };
};


```

2.客户端收发数据

```js
// 这段代码是必须的，打开页面后注册SharedWorker，显示指定worker.port.start()方法建立与worker间的连接
    if (typeof Worker === "undefined") {
      alert('当前浏览器不支持webworker')
    } else {
      let worker = new SharedWorker('worker.js')
      worker.port.addEventListener('message', (e) => {
        console.log('来自worker的数据：', e.data)
      }, false)
      worker.port.start()
      window.worker = worker
    }
// 获取和发送消息都是调用postMessage方法，我这里约定的是传递'get'表示获取数据。
window.worker.port.postMessage('get')
window.worker.port.postMessage('发送信息给worker')
```

参考：[多个标签页之间通信](https://github.com/libin1991/libin_Blog/issues/522#)





## 简述前端性能优化常用的几种方式？

参考：[项目性能优化](https://juejin.cn/post/6844903830979608584#heading-13)













## 什么是 webp? 浏览器如何判断是否支持 webp 格式图片?











## 介绍下 BFC 及其应用？创建 BFC 的方式？

## 简述 Rem 及其转换原理?

写 React / Vue 项目时为什么要在列表组 件中写 key，其作用是什么?

什么是防抖和节流?有什么区别? 如何实现?

JS 异步解决 方案的发展历程以及优缺点?

简述浏览器缓存读取规则?

如何实现一个 sleep 函数？

为什么通常在发送数据埋点请求的时候使 用的是 1x1 像素的透明 gif 图片?

ES6 代码转成 ES5 代码的实现思路是什么?

简单说说 js 中有哪几种内存泄露的情况？

讲讲instanceof 的实现原理?

什么是 CSRF 攻击?如何防范 CSRF 攻击?

什么是 XSS 攻击?如何防范 XSS 攻击?

移动端 300 ms 点击(click 事件)延迟原因？如何解决？

移动端1px的产生原因？如何解决？

webpack 中 loader 和 plugin 的区别是什么?

简述 HTTP2.0 与 HTTP1.1 相较于之前 版本的改进？

请介绍一下 require 的模块加载机制？

在 Node 中两个模块互相引用会发生什么?原因？

前端如何做权限校验？思路是？

0.1 + 0.2等于多少？原因是？

如何避免回流和重绘？

编译语法树的原理？

es6转es5的原理？关键步骤？

babel原理?